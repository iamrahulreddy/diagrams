import React, { useState, useEffect, useMemo, useCallback } from "react";
import {
  Server,
  Info,
  Activity,
  Clock,
  AlertCircle,
  Check,
  HelpCircle,
  Play,
  Pause,
  RefreshCcw,
  Terminal,
  Cpu,
  Loader,
  Users,
  Monitor,
  MemoryStick
} from "lucide-react";

const stagesData = [
  {
    name: "Power On / Firmware (BIOS/UEFI)",
    description: "Initial hardware checks and boot device selection.",
    detailedDescription:
      "The system is powered on. The firmware (BIOS or UEFI) performs a Power-On Self-Test (POST) to ensure essential hardware components are functioning correctly. It initializes the CPU, memory, and other peripherals. The firmware then identifies the boot device based on the configured boot order (e.g., hard drive, SSD, USB) and loads the bootloader from that device.",
    icon: <Server className="w-5 h-5" />,
    tasks: [
      "Power-On Self-Test (POST)",
      "Hardware initialization (CPU, Memory, etc.)",
      "Boot device detection",
      "Load bootloader",
    ],
    commonIssues: [
      "Incorrect boot order in BIOS/UEFI settings",
      "Hardware failure (indicated by POST error codes - beeps or on-screen messages)",
      "Corrupted firmware (BIOS/UEFI)",
      "Failed boot device (hard drive, SSD)",
    ],
    advancedDetails:
      "BIOS (Basic Input/Output System): Older firmware standard. Simpler interface, limited features. \n" +
      "UEFI (Unified Extensible Firmware Interface): Modern replacement for BIOS. More advanced, supports larger disks, faster booting, and features like Secure Boot. \n" +
      "POST Codes: Specific beep sequences or on-screen codes indicate the nature of hardware failures during POST. Refer to your motherboard's manual for detailed interpretations. \n" +
      "Boot Order: The sequence in which the firmware searches for a bootable device. \n" +
      "Secure Boot: A UEFI feature that ensures only trusted software is loaded during boot, preventing malware from loading early in the process. Can sometimes interfere with booting certain Linux distributions if not configured properly.",
    troubleshooting: [
      "Check BIOS/UEFI settings for correct boot order. Ensure the desired boot device is listed first.",
      "Consult motherboard manual for POST error code meanings. For example, a single beep often indicates successful POST, while multiple beeps or no beeps can point to specific problems.",
      "Reseat RAM modules, graphics card, and other components to ensure good connections.",
      "Attempt to boot from a different device (e.g., a USB drive with a live Linux distribution).",
      "If you suspect corrupted firmware, try updating or reflashing the BIOS/UEFI (with extreme caution, as this can brick your motherboard if done incorrectly).",
    ],
    timeRange: "2-15 seconds",
    color: "bg-blue-500",
  },
  {
    name: "Bootloader (GRUB)",
    description: "Loads the kernel and initramfs.",
    detailedDescription:
      "The bootloader (commonly GRUB on Linux systems) takes control from the firmware. Its primary role is to load the Linux kernel and the initial RAM disk (initramfs) into memory. GRUB often presents a menu allowing you to choose between different operating systems (if you have a multi-boot setup) or different kernel versions. It also passes essential boot parameters to the kernel, influencing how the kernel behaves during initialization.",
    icon: <Loader className="w-5 h-5 animate-spin" />,
    tasks: [
      "Load kernel image into memory",
      "Load initramfs into memory",
      "Present boot menu (optional)",
      "Pass boot parameters to the kernel",
    ],
    commonIssues: [
      "Corrupted GRUB configuration file (e.g., `/boot/grub/grub.cfg`)",
      "Incorrect kernel parameters",
      "Missing or corrupted kernel image or initramfs files",
      "Problems after a system update or new kernel installation",
    ],
    advancedDetails:
      "GRUB (Grand Unified Bootloader): A powerful and flexible bootloader. \n" +
      "GRUB Configuration: Usually located at `/boot/grub/grub.cfg`. It's a complex file that defines the boot menu entries and kernel parameters. It's often automatically generated by tools like `update-grub`. Editing it manually requires a good understanding of GRUB's syntax. \n" +
      "Kernel Parameters: These are options passed to the kernel during boot to modify its behavior. Examples include `quiet` (suppress verbose output), `splash` (show a splash screen), `nomodeset` (disable kernel mode setting for graphics), `single` (boot into single-user mode for troubleshooting). \n" +
      "Multi-boot: GRUB can be configured to chainload other bootloaders, allowing you to boot different operating systems installed on the same machine. \n" +
      "Secure Boot: In Secure Boot environments, the bootloader must be digitally signed to be considered trusted by the firmware.",
    troubleshooting: [
      "Boot from a live Linux environment (USB or DVD) and use tools to repair GRUB (e.g., `boot-repair` utility).",
      "If you are familiar with the GRUB command-line interface, you can use the GRUB rescue prompt to manually specify the kernel and initramfs to boot.",
      "Verify that the kernel image (e.g., `vmlinuz-6.1.0-14-amd64`) and initramfs files (e.g., `initrd.img-6.1.0-14-amd64`) exist in the `/boot` directory.",
      "After a kernel update that causes boot problems, try selecting an older kernel from the GRUB menu.",
    ],
    timeRange: "1-5 seconds",
    color: "bg-green-500",
  },
  {
    name: "Kernel Initialization",
    description: "Core OS setup and driver loading.",
    detailedDescription:
      "The kernel takes over from the bootloader. It's the heart of the Linux operating system. The kernel initializes core components like memory management, process scheduling, and loads essential hardware drivers. It detects and configures attached hardware devices. After basic initialization, it mounts the root filesystem (the primary filesystem where the operating system resides), as specified by the boot parameters.",
    icon: <Cpu className="w-5 h-5" />,
    tasks: [
      "Decompress kernel image",
      "Initialize CPU and memory management",
      "Detect and initialize hardware devices",
      "Load kernel modules (drivers)",
      "Mount the root filesystem",
    ],
    commonIssues: [
      "Missing or incompatible device drivers (especially for storage controllers or graphics cards)",
      "Kernel panic (a critical error that halts the system)",
      "Filesystem errors on the root filesystem",
      "Hardware conflicts",
    ],
    advancedDetails:
      "Kernel Modules: These are pieces of code that can be dynamically loaded into the kernel to extend its functionality, often used for device drivers. You can manage them with commands like `lsmod` (list), `insmod` (insert), `rmmod` (remove). \n" +
      "Device Tree (DTB): On many ARM-based systems (like Raspberry Pi), the Device Tree is a data structure that describes the hardware to the kernel, allowing a single kernel image to support different hardware configurations. \n" +
      "dmesg: A command that displays kernel messages, which are crucial for diagnosing hardware detection and driver loading issues during boot. \n" +
      "Kernel Parameters: Parameters like `root=/dev/sda1` (specifies the root filesystem device) and `ro` (mount root filesystem read-only) are passed by the bootloader and have significant impact here. \n" +
      "ACPI (Advanced Configuration and Power Interface): A standard used by the kernel to manage power and interact with hardware. ACPI tables provide information about devices and their power states.",
    troubleshooting: [
      "If you encounter a kernel panic, carefully note the error messages displayed on the screen, as they often provide clues about the cause.",
      "Boot with a previously known working kernel (if available from the GRUB menu).",
      "Use kernel parameters like `nomodeset` (for graphics issues) or `single` (for single-user mode troubleshooting).",
      "Examine kernel logs using `dmesg` or by looking at `/var/log/kern.log` (or similar files depending on your distribution) for errors related to hardware detection or driver loading.",
      "If you suspect a hardware conflict, try disabling devices in the BIOS/UEFI settings (e.g., onboard sound or network card) to see if it resolves the issue.",
    ],
    timeRange: "1-10 seconds",
    color: "bg-yellow-500",
  },
  {
    name: "Initial RAM Disk (initramfs)",
    description: "Prepares the root filesystem and loads necessary modules.",
    detailedDescription:
      "The initramfs (initial RAM filesystem) is a temporary root filesystem that is loaded into RAM during the boot process. It contains essential tools, scripts, and kernel modules needed to mount the real root filesystem and continue the boot process. It's particularly crucial when the root filesystem is on a complex storage setup (e.g., encrypted, RAID, LVM) or requires specific drivers that are not built directly into the kernel.",
    icon: <MemoryStick className="w-5 h-5" />,
    tasks: [
      "Load necessary kernel modules (e.g., for storage, encryption)",
      "Set up device mapper volumes (LVM, RAID)",
      "Decrypt the root filesystem (if encrypted)",
      "Mount the real root filesystem",
      "Hand over control to the init system on the real root filesystem",
    ],
    commonIssues: [
      "Missing or incorrect modules in the initramfs (preventing the root filesystem from being mounted)",
      "Incorrect initramfs configuration (especially for custom setups)",
      "Problems with encrypted volumes (incorrect passphrase, corrupted encryption header)",
      "Boot failures after updating the kernel or initramfs",
    ],
    advancedDetails:
      "initramfs Structure: It's typically a compressed cpio archive. You can inspect its contents using tools like `lsinitramfs` (on Debian/Ubuntu) or by manually extracting it. \n" +
      "initramfs Generation: Tools like `update-initramfs` (Debian/Ubuntu) or `dracut` (Fedora/Red Hat) are used to create and update the initramfs. These tools automatically include necessary modules and scripts based on your system's configuration. \n" +
      "Customization: You can customize the initramfs by adding scripts or modules to handle specific hardware or boot requirements. This usually involves modifying configuration files in `/etc/initramfs-tools` (Debian/Ubuntu) or `/etc/dracut.conf.d` (Fedora/Red Hat). \n" +
      "init Script: The `init` script within the initramfs is the main script that orchestrates the early boot process. It's responsible for loading modules, mounting filesystems, and eventually handing over control to the init system on the real root filesystem.",
    troubleshooting: [
      "Rebuild the initramfs using `update-initramfs -u -k all` (Debian/Ubuntu) or `dracut -f` (Fedora/Red Hat). This often fixes problems caused by missing or outdated modules.",
      "Carefully inspect the initramfs contents using `lsinitramfs` to verify that the necessary modules and scripts are present.",
      "Check boot parameters related to the initramfs (e.g., `rd.break` to drop into a debug shell within the initramfs) for troubleshooting.",
      "If you are dealing with encrypted volumes, double-check that you are using the correct passphrase and that the encryption setup is properly configured.",
    ],
    timeRange: "0.5-3 seconds",
    color: "bg-purple-500",
  },
  {
    name: "Init System (systemd)",
    description: "Starts system services and manages the user environment.",
    detailedDescription:
      "The init system is the first process started by the kernel (its process ID is always 1). On most modern Linux distributions, systemd is the init system. It's responsible for starting and managing system services (daemons), mounting filesystems (as defined in `/etc/fstab`), setting up networking, and managing user sessions. Systemd uses unit files to define and control services and their dependencies.",
    icon: <Activity className="w-5 h-5" />,
    tasks: [
      "Start system services (daemons)",
      "Mount filesystems (according to /etc/fstab)",
      "Configure networking (interfaces, IP addresses, DNS)",
      "Manage user sessions (login, logout)",
      "Handle system shutdown and reboot",
    ],
    commonIssues: [
      "Service startup failures (due to misconfiguration, missing dependencies, or errors in the service itself)",
      "Filesystem mount errors (incorrect entries in `/etc/fstab`, missing filesystems)",
      "Network configuration problems (incorrect IP settings, DNS resolution issues)",
      "Conflicts between services",
    ],
    advancedDetails:
      "systemd: A powerful and complex init system that provides significant advantages over older init systems like SysVinit. It uses a declarative approach to service management, with dependencies and relationships between services explicitly defined. \n" +
      "Unit Files: These are configuration files that define how systemd manages services, mounts, devices, sockets, etc. They are typically located in `/etc/systemd/system` or `/usr/lib/systemd/system`. \n" +
      "Targets: systemd uses targets to group units and define different system states. For example, `multi-user.target` is similar to the traditional runlevel 3, while `graphical.target` is similar to runlevel 5. \n" +
      "journalctl: A powerful command-line tool for viewing and querying the systemd journal, which contains log messages from the kernel, systemd, and various services. \n" +
      "systemctl: The primary command-line tool for interacting with systemd. You can use it to start, stop, enable, disable, and check the status of services.",
    troubleshooting: [
      "Use `systemctl status <service>` to check the status of a specific service and identify any errors.",
      "Examine the systemd journal using `journalctl` to find error messages related to service failures, filesystem issues, or network problems.",
      "Check unit file configurations in `/etc/systemd/system` or `/usr/lib/systemd/system` for errors or missing dependencies.",
      "Verify filesystem entries in `/etc/fstab` for correctness.",
      "If you encounter network issues, use tools like `ip`, `ping`, and `nslookup` to diagnose the problem.",
      "Use `systemctl list-dependencies <target>` to understand the dependencies of a particular target.",
      "As a last resort, you can try booting into a different target (e.g., `rescue.target` or `emergency.target`) to troubleshoot the system in a minimal environment.",
    ],
    timeRange: "3-15 seconds",
    color: "bg-indigo-500",
  },
  {
    name: "Display Manager",
    description: "Provides graphical login.",
    detailedDescription:
      "The display manager is responsible for starting the display server (X Window System or Wayland) and providing a graphical login screen. It handles user authentication and starts the user's chosen desktop environment after successful login. Common display managers include GDM (GNOME), LightDM, and SDDM (KDE).",
    icon: <Monitor className="w-5 h-5" />,
    tasks: [
      "Start the display server (Xorg or Wayland)",
      "Display the login screen (greeter)",
      "Authenticate users (verify username and password)",
      "Start the user's desktop environment (e.g., GNOME, KDE, Xfce)",
    ],
    commonIssues: [
      "Display manager fails to start, resulting in a blank screen or a text-mode login",
      "Authentication problems (incorrect password, user account issues)",
      "Desktop environment fails to load or crashes after login",
      "Graphical glitches or driver problems",
    ],
    advancedDetails:
      "X Window System (Xorg): The traditional display server for Linux. It provides a framework for graphical user interfaces. \n" +
      "Wayland: A newer, more modern display server protocol that is gradually replacing Xorg. It aims to be simpler and more efficient. \n" +
      "Display Managers: These are programs that manage user logins and start the appropriate display server and desktop environment. \n" +
      "Desktop Environments: These provide the complete graphical user experience, including the window manager, panels, system menus, and default applications (e.g., file manager, terminal). \n" +
      "Configuration: Display managers have their own configuration files (e.g., `/etc/lightdm/lightdm.conf` for LightDM). Desktop environments are typically configured through settings within the desktop environment itself.",
    troubleshooting: [
      "If the display manager fails to start, try switching to a text console (Ctrl+Alt+F1-F6) and examining logs in `/var/log/Xorg.0.log` (for Xorg) or the output of `journalctl`.",
      "Check the display manager's logs (e.g., `/var/log/lightdm` for LightDM) for errors.",
      "Verify user account permissions and try logging in as a different user.",
      "If the desktop environment fails to load, try selecting a different desktop environment from the login screen (if available).",
      "Check for errors in the user's `.xsession-errors` file in their home directory.",
      "If you suspect a graphics driver problem, try booting with the `nomodeset` kernel parameter or reinstalling/updating your graphics drivers.",
    ],
    timeRange: "2-8 seconds",
    color: "bg-pink-500",
  },
  {
    name: "User Space & Desktop Environment",
    description: "User login, session management, and application launch.",
    detailedDescription:
      "After successful login through the display manager, the user's desktop environment is loaded. User-specific services, applications, and daemons are started. The system is now fully operational and ready for user interaction. This stage involves managing user sessions, launching applications, and handling user-level configurations.",
    icon: <Users className="w-5 h-5" />,
    tasks: [
      "Start the user's session",
      "Load the desktop environment (window manager, panels, etc.)",
      "Launch user-specific applications and services",
      "Apply user configurations and settings",
    ],
    commonIssues: [
      "Desktop environment crashes or freezes",
      "Applications fail to start or crash frequently",
      "User configuration errors (corrupted dotfiles)",
      "Performance issues (slow application startup, high resource usage)",
    ],
    advancedDetails:
      "Session Management:  Handles the user's login session, including starting and stopping processes, managing resources, and saving session state. \n" +
      "Desktop Environment Configuration: Each desktop environment has its own way of storing user settings. These are often stored in dotfiles (hidden files and directories) in the user's home directory (e.g., `.config`, `.local`). \n" +
      "XDG Specifications: A set of standards that aim to improve interoperability between desktop environments and applications by defining common locations for configuration files, data files, and cache files. \n" +
      "Autostart Applications: Many desktop environments allow you to configure applications that automatically start when you log in. These are usually defined in `.desktop` files located in `~/.config/autostart`. \n" +
      "System Monitoring Tools: Tools like `top`, `htop`, and `gnome-system-monitor` can be used to monitor resource usage (CPU, memory, disk I/O) and identify processes that might be causing problems.",
    troubleshooting: [
      "If the desktop environment crashes, check the `.xsession-errors` file in the user's home directory for error messages.",
      "Try logging in with a different user account to see if the problem is specific to a particular user's configuration.",
      "If an application is causing problems, try starting it from the terminal to see if any error messages are displayed.",
      "Temporarily move or rename dotfiles in your home directory to see if they are causing the issue. Be careful, as this can reset your desktop settings.",
      "Use system monitoring tools to identify resource-intensive processes that might be causing performance issues.",
      "Check application logs (often located in `~/.local/share` or `~/.cache`) for clues about application crashes.",
    ],
    timeRange: "2-10 seconds",
    color: "bg-teal-500",
  },
];

const StageButton = ({ stage, index, currentStage, onClick }) => (
  <button
    onClick={() => onClick(index)}
    className={`relative flex items-center space-x-1 sm:space-x-2 px-3 sm:px-5 py-2 sm:py-3 rounded-xl text-xs sm:text-sm font-medium transition-colors focus:outline-none flex-shrink-0
      ${
        currentStage === index
          ? `${stage.color} text-white shadow-lg hover:brightness-110`
          : "bg-gray-100 hover:bg-gray-200 text-gray-700"
      }`}
  >
    {React.cloneElement(stage.icon, {
      className: "w-4 h-4 sm:w-5 sm:h-5 flex-shrink-0",
    })}
    <span className="whitespace-nowrap">{stage.name}</span>
  </button>
);

const StageDetails = ({ stage }) => (
  <div className="space-y-4 sm:space-y-6">
    <div
      className={`${stage.color.replace("bg", "bg-opacity-10")} border border-${
        stage.color.split("-")[0]
      }-200 rounded-lg p-4 sm:p-5`}
    >
      <h3 className="font-semibold text-base sm:text-lg text-gray-800 flex items-center space-x-2">
        {React.cloneElement(stage.icon, {
          className: "w-4 h-4 sm:w-5 sm:h-5 flex-shrink-0",
        })}
        <span>{stage.name}</span>
      </h3>
      <p className="text-gray-700 text-sm mt-2">{stage.description}</p>
    </div>

    <div className="bg-cyan-100 rounded-lg shadow-sm border border-gray-200">
      <div className="px-4 sm:px-5 py-3 sm:py-4 border-b border-gray-200">
        <h4 className="font-semibold text-sm sm:text-md text-gray-700 flex items-center space-x-2">
          <Check className="w-4 h-4 text-green-500 flex-shrink-0" />
          <span>Key Tasks</span>
        </h4>
      </div>
      <ul className="p-4 sm:p-5 space-y-2 sm:space-y-3">
        {stage.tasks.map((task, index) => (
          <li
            key={index}
            className="text-gray-600 text-xs sm:text-sm flex items-center space-x-2"
          >
            <div className="w-1.5 sm:w-2 h-1.5 sm:h-2 rounded-full bg-green-500 flex-shrink-0"></div>
            <span>{task}</span>
          </li>
        ))}
      </ul>
    </div>
  </div>
);

const LinuxBootingVisualizer = () => {
  const [currentStage, setCurrentStage] = useState(0);
  const [simulationSpeed, setSimulationSpeed] = useState(3000);
  const [isAutoPlay, setIsAutoPlay] = useState(true);
  const [progress, setProgress] = useState(0);
  const [particles, setParticles] = useState([]);
  const [currentPhase, setCurrentPhase] = useState(0);
  const [lines, setLines] = useState([]);
  const [isRunning, setIsRunning] = useState(true);
  const [speed, setSpeed] = useState(50);

  const stages = useMemo(() => stagesData, []);

  const bootSequence = [
    // Power On / Firmware Phase
    [
      "[    0.000000]  INFO:  Power ON initiated.",
      "[    0.000010]  INFO:  System Reset - Begin Hardware Initialization.",
      "[    0.000050]  DEBUG: Performing CMOS checksum...",
      "[    0.000100]  DEBUG: Checksum OK",
      "[    0.001000]  INFO:  Performing Power-On Self Test (POST)...",
      "[    0.001250]  DEBUG: Testing RAM modules...",
      "[    0.003000]  DEBUG: RAM Test Passed.",
      "[    0.003200]  DEBUG: Testing CPU Core 0...",
      "[    0.003400]  DEBUG: Testing CPU Core 1...",
      "[    0.003800]  DEBUG: All CPU cores OK.",
      "[    0.005000]  INFO: Checking hardware components (USB, PCI, SATA)...",
      "[    0.006000]  DEBUG: USB controller found: Device 0x1234:0xabcd.",
      "[    0.006100]  DEBUG: SATA Controller: Found Controller Intel 0x8086:0xa102",
      "[    0.008000]  DEBUG: PCI device: Network controller: Realtek 0x10ec:0x8168 detected.",
      "[    0.009000]  INFO:  Initializing CPU and memory...",
      "[    0.009100]  DEBUG:  CPU microcode update loaded.",
      "[    0.012000]  DEBUG: Allocating 8 GB of memory for kernel space.",
      "[    0.014000] INFO:  Detecting boot device...",
      "[    0.015000]  DEBUG: Scanning for bootable disks...",
      "[    0.018000]  DEBUG: Found SATA drive at /dev/sda",
      "[    0.018500]  DEBUG: Checking partition table of /dev/sda",
      "[    0.020000] INFO:  Boot device found: /dev/sda1",
      "[    0.022000]  DEBUG: Partition type ext4",
      "[    0.025000]  INFO: Loading bootloader...",
    ],
    // Bootloader Phase
    [
      "[    0.026000]  INFO:  GRUB version 2.06, Starting.",
      "[    0.028000]  DEBUG: Loading GRUB configuration from /boot/grub/grub.cfg",
      "[    0.030000]  DEBUG: Selected boot entry: 'Linux 6.1.0-14-amd64'",
      "[    0.040000] INFO: Loading Linux kernel 6.1.0-14-amd64...",
      "[    0.050000]  DEBUG: Kernel Image loading from /boot/vmlinuz-6.1.0-14-amd64 ...",
      "[    0.070000]  DEBUG: Kernel Image loaded at address 0xffffffff",
      "[    0.075000] INFO: Loading initial RAM disk...",
      "[    0.080000] DEBUG: Initramfs Image loading from /boot/initrd.img-6.1.0-14-amd64...",
      "[    0.100000]  DEBUG: Initramfs loaded successfully.",
      "[    0.130000]  INFO: Passing control to the Linux Kernel.",
      "[    0.132513] [KRNL] Initializing cgroup subsys cpuset",
      "[    0.133024] [KRNL] Initializing cgroup subsys cpu",
    ],
    // Kernel Initialization Phase
    [
      "[    1.000000] [KRNL] Linux version 6.1.0-14-amd64 (build@builder1) #1 SMP PREEMPT_DYNAMIC Debian 6.1.27-1 (2023-07-22)",
      "[    1.002000] [KRNL] Kernel command line:  BOOT_IMAGE=/boot/vmlinuz-6.1.0-14-amd64 root=/dev/sda1 ro quiet splash",
      "[    1.005000]  [KRNL] x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'",
      "[    1.015564] [KRNL] Initializing system time...",
      "[    1.016000]  [KRNL] Using RTC device to load initial system time.",
      "[    1.016960] [KRNL] Detecting CPU information...",
      "[    1.018000]  [KRNL]  Detected Intel(R) Core(TM) i7-8700K CPU @ 3.70GHz",
      "[    1.019870] [KRNL] Loading drivers...",
      "[    1.030000] [KRNL]    USB 3.0 Host Controller (xhci_hcd) loading....",
      "[    1.040000]  [KRNL]   SATA Driver (ahci) loading ...",
      "[    1.060000]  [KRNL]  eth1  Driver (r8169) Loading...",
      "[    1.165000]  [KRNL]  Audio device (snd_hda_intel) loading...",
      "[    1.167730] [KRNL] Initializing storage devices...",
      "[    1.168000] [KRNL]  sda: 476940MB WDC WDS500G2B0C-00PXH0 ",
      "[    1.168223] [KRNL] Mounting root filesystem...",
      "[    1.200000]  [KRNL] VFS: Mounted root (ext4 filesystem) readonly on device sda1",
    ],
    // Initramfs Phase
    [
      "[    1.500000] [KRNL] Loading initramfs...",
      "[    1.505000] [KRNL]    Extracting initramfs ...",
      "[    1.510000] [INITRAMFS] Checking root filesystem...",
      "[    1.515000] [INITRAMFS]   fsck check completed on /dev/sda1 - clean.",
      "[    1.520000] [INITRAMFS] Loading storage drivers...",
      "[    1.525000] [INITRAMFS] Module ahci.ko loaded.",
      "[    1.530000] [INITRAMFS] Mounting /dev/sda1...",
      "[    1.535000]  [INITRAMFS]   Mount Successful /mnt/root.",
      "[    1.538000] [INITRAMFS] Copying / from /mnt/root.",
      "[    1.540000] [INITRAMFS] Switching to real root...",
      "[    1.550000] [INITRAMFS] Done.",
    ],
    // Init System Phase
    [
      "[    2.300000] [INIT]   Starting /sbin/init ...",
      "[    2.324502] [SYSTEMD] systemd[1]: Starting systemd...",
      "[    2.325000] [SYSTEMD] systemd[1]: Reading init configuration files...",
      "[    2.325890] [SYSTEMD] systemd[1]: Detecting architecture...",
      "[    2.327000] [SYSTEMD] systemd[1]: Arch : x86-64",
      "[    2.327512] [SYSTEMD] systemd[1]: Setting hostname...",
      "[    2.328500] [SYSTEMD] systemd[1]:  Setting hostname to localhost",
      "[    2.329001] [SYSTEMD] systemd[1]: Starting essential services...",
      "[    2.330000] [SYSTEMD] systemd[1]:  Starting journald",
      "[    2.330512] [SYSTEMD] systemd[1]: Mounting filesystems...",
      "[    2.331500] [SYSTEMD] systemd[1]: Mounting all required mounts.",
      "[    2.332001] [SYSTEMD] systemd[1]: Configuring networking...",
      "[    2.335000] [SYSTEMD] systemd[1]:  Setting hostname - networking configuration complete.",
    ],
    // Display Manager Phase
    [
      "[    3.000000] [SYSTEMD] Starting user managers ...",
      "[    3.200000] [SYSTEMD] systemd[1]: Reached target Multi-User System.",
      "[    3.300000] [SYSTEMD]  Starting GDM.service..",
      "[    3.500000] [GDM] Starting display manager...",
      "[    3.510000] [XSERVER] Initializing X server...",
      "[    3.515000] [XSERVER]   Using display :0...",
      "[    3.518000] [XSERVER]   Loading video drivers ...",
      "[    3.520000] [GDM] Loading GDM...",
      "[    3.525000] [GDM] Starting GDM display manager",
      "[    3.530000] [GDM] Displaying login screen...",
      "[    3.540000] [GDM] DisplayManager: Logging in Session 1",
    ],
    // User Space & Desktop Environment Phase
    [
      "[    4.000000]  [SYSTEMD] User Session logged in",
      "[    4.100000]  [SYSTEMD] Loading KDE session ..",
      "[    4.152390] [SYSTEMD] systemd[1]: Reached target Graphical Interface.",
      "Welcome to Linux!",
      "localhost login: ",
    ],
  ];

  // Synchronize terminal phases with stage changes
  useEffect(() => {
    if (currentStage !== currentPhase) {
      setCurrentPhase(currentStage);
      setLines([]); // Reset lines when the phase changes
    }
  }, [currentStage, currentPhase]);

  useEffect(() => {
    if (!isRunning) return;

    const currentSequence = bootSequence[currentPhase];
    if (!currentSequence) return;

    let lineIndex = lines.length;

    // Check if we've already displayed all lines for the current phase
    if (lineIndex >= currentSequence.length) {
      return; // Don't set up a new interval if all lines are displayed
    }

    const interval = setInterval(() => {
      if (lineIndex < currentSequence.length) {
        setLines((prev) => [...prev, currentSequence[lineIndex]]);
        lineIndex++;
      } else {
        clearInterval(interval);
      }
    }, speed);

    return () => clearInterval(interval);
  }, [currentPhase, isRunning, lines.length, speed, bootSequence]);

  useEffect(() => {
    let interval;
    if (isAutoPlay) {
      interval = setInterval(() => {
        setCurrentStage((prevStage) => (prevStage + 1) % stages.length);
        setProgress(
          (prevProgress) => (prevProgress + 100 / stages.length) % 100
        );
      }, simulationSpeed);
    }
    return () => clearInterval(interval);
  }, [isAutoPlay, simulationSpeed, stages.length]);

  useEffect(() => {
    if (isAutoPlay) {
      const newParticles = Array.from({ length: 5 }).map(() => ({
        id: Math.random(),
        x: Math.random() * 100,
        y: Math.random() * 100,
        size: Math.random() * 4 + 2,
        duration: Math.random() * 2 + 1,
        color: stages[currentStage].color.replace("bg-", ""),
      }));
      setParticles(newParticles);

      const timeout = setTimeout(() => {
        setParticles([]);
      }, 1000);

      return () => clearTimeout(timeout);
    }
  }, [currentStage, isAutoPlay, stages]);

  const handleStageClick = useCallback(
    (index) => {
      setCurrentStage(index);
      setIsAutoPlay(false);
      setProgress((index / stages.length) * 100);
    },
    [stages.length]
  );

  const reset = () => {
    setCurrentStage(0);
    setCurrentPhase(0);
    setLines([]);
    setIsRunning(true);
    setProgress(0);
  };

  return (
    <div className="bg-gray-50 font-mono min-h-screen py-4 sm:py-6 md:py-10 px-2 sm:px-4">
      <div className="mx-auto max-w-7xl bg-white rounded-xl shadow-lg overflow-hidden">
        {/* Header & Navigation */}
        <div className="px-3 sm:px-6 py-3 border-b border-gray-200 bg-gray-50 flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-3 sm:space-y-0">
          <div>
            <h2 className="text-lg sm:text-xl text-gray-800 flex items-center space-x-2">
              <Server className="w-5 h-5 sm:w-6 sm:h-6 font-bold text-blue-500 flex-shrink-0" />
              <span>Linux Boot Process</span>
            </h2>
            <p className="text-gray-500 text-xs sm:text-sm mt-1">
              Step-by-step visualization from power-on to login.
            </p>
          </div>
          <div className="flex flex-col sm:flex-row items-start sm:items-center space-y-2 sm:space-y-0 sm:space-x-6 w-full sm:w-auto">
            <div className="flex items-center space-x-2 text-xs sm:text-sm text-gray-600">
              <Clock className="w-4 h-4 flex-shrink-0" />
              <span>Typical Duration: {stages[currentStage].timeRange}</span>
            </div>
            <div className="flex items-center space-x-2 w-full sm:w-auto">
              <button
                onClick={() => setIsAutoPlay(!isAutoPlay)}
                className={`px-3 sm:px-4 py-1.5 sm:py-2 rounded-md text-xs sm:text-sm font-medium focus:outline-none transition-colors flex-1 sm:flex-none flex items-center justify-center
                  ${
                    isAutoPlay
                      ? "bg-red-100 text-red-600 hover:bg-red-200"
                      : "bg-green-100 text-green-600 hover:bg-green-200"
                  }`}
              >
                {isAutoPlay ? (
                  <Pause className="w-4 h-4 mr-1" />
                ) : (
                  <Play className="w-4 h-4 mr-1" />
                )}
                {isAutoPlay ? "Pause" : "Play"}
              </button>
              <select
                value={simulationSpeed}
                onChange={(e) => setSimulationSpeed(Number(e.target.value))}
                className="px-2 sm:px-3 py-1.5 sm:py-2 rounded-md border border-gray-300 text-xs sm:text-sm focus:outline-none"
              >
                <option value={1000}>Fast</option>
                <option value={3000}>Normal</option>
                <option value={5000}>Slow</option>
              </select>
            </div>
          </div>
        </div>

        {/* Stage Navigation */}
        <div className="p-4 sm:p-6">
          <div className="flex flex-col sm:flex-row gap-2 sm:space-x-4 overflow-x-auto mb-2 sm:mb-4">
            {stages.map((stage, index) => (
              <StageButton
                key={index}
                stage={stage}
                index={index}
                currentStage={currentStage}
                onClick={handleStageClick}
              />
            ))}
          </div>

          {/* Progress Bar */}
          <div className="relative bg-gray-200 rounded-full h-2 mb-6 sm:mb-8 overflow-hidden">
            <div
              className="h-full rounded-full transition-all duration-100"
              style={{
                width: `${progress}%`,
                backgroundColor:
                  stages[currentStage].color.split("-")[0] !== "bg"
                    ? stages[currentStage].color
                    : stages[currentStage].color
                        .replace("bg", "")
                        .replace("-500", "-600"),
                transition: "width 0.3s linear", // Smoother transition
              }}
            />
          </div>

          {/* Terminal and Stage Details */}
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-6 md:gap-8">
            {/* Terminal Output */}
            <div className="md:col-span-2 lg:col-span-2">
              <div className="bg-black rounded-lg shadow-2xl border border-gray-700 overflow-hidden">
                {/* Terminal Header */}
                <div className="bg-gray-800 p-3 flex items-center justify-between">
                  <div className="flex items-center space-x-2">
                    <Terminal className="w-5 h-5 text-gray-400" />
                    <span className="text-gray-300 text-sm">
                      Linux Boot Process
                    </span>
                  </div>
                  <div className="flex items-center space-x-3">
                    <button
                      onClick={reset}
                      className="text-gray-300 hover:text-white"
                    >
                      <RefreshCcw className="w-4 h-4" />
                    </button>
                  </div>
                </div>

                {/* Terminal Content */}
                <div className="p-4 h-[400px] overflow-auto">
                  <div className="space-y-1 font-mono text-sm">
                    {lines.map((line, index) => (
                      <div
                        key={index}
                        className={`text-gray-300 ${
                          line?.startsWith("[")
                            ? "text-green-400"
                            : line?.includes("error")
                            ? "text-red-400"
                            : line?.includes("Warning")
                            ? "text-yellow-400"
                            : "text-gray-300"
                        }`}
                      >
                        {line}
                      </div>
                    ))}
                    <div className="text-gray-300 animate-pulse">_</div>
                  </div>
                </div>

                {/* Progress Bar for Terminal */}
                <div className="bg-gray-800 p-3">
                  <div className="h-2 bg-gray-700 rounded-full">
                    <div
                      className="h-full bg-green-500 rounded-full transition-all duration-300"
                      style={{
                        width: `${(currentPhase + 1) * (100 / stages.length)}%`,
                      }}
                    />
                  </div>
                  <div className="mt-2 text-xs text-gray-400 text-center">
                    {stages[currentPhase]?.name}
                  </div>
                </div>
              </div>
            </div>

            {/* Stage Details */}
            <div className="md:col-span-2 lg:col-span-1 space-y-4 sm:space-y-6">
              <StageDetails stage={stages[currentStage]} />

              {/* Explanation */}
              <div className="bg-white rounded-lg shadow-sm border border-gray-200">
                <div className="px-4 sm:px-5 py-3 sm:py-4 border-b border-gray-200">
                  <h4 className="font-semibold text-sm sm:text-md text-gray-700 flex items-center space-x-2">
                    <Info className="w-4 h-4 text-blue-500 flex-shrink-0" />
                    <span>Explanation</span>
                  </h4>
                </div>
                <div className="p-4 sm:p-5">
                  <p className="text-gray-700 text-xs sm:text-sm">
                    {stages[currentStage].detailedDescription}
                  </p>
                  {stages[currentStage].advancedDetails && (
                    <details className="mt-4">
                      <summary className="text-blue-500 text-xs sm:text-sm cursor-pointer">
                        More Details
                      </summary>
                      <p className="text-gray-600 text-xs mt-2">
                        {stages[currentStage].advancedDetails}
                      </p>
                    </details>
                  )}
                </div>
              </div>

              {/* Common Issues & Troubleshooting */}
              <div className="bg-orange-50 border border-orange-200 rounded-lg p-4 sm:p-5">
                <h4 className="font-semibold text-sm sm:text-md text-orange-700 flex items-center space-x-2">
                  <AlertCircle className="w-4 h-4 text-orange-500 flex-shrink-0" />
                  <span>Common Issues</span>
                </h4>
                <ul className="mt-3 space-y-2 sm:space-y-3">
                  {stages[currentStage].commonIssues.map((issue, index) => (
                    <li
                      key={index}
                      className="text-orange-700 text-xs sm:text-sm flex items-center space-x-2"
                    >
                      <div className="w-1.5 h-1.5 rounded-full bg-orange-500 flex-shrink-0"></div>
                      <span>{issue}</span>
                    </li>
                  ))}
                </ul>
              </div>

              {stages[currentStage].troubleshooting && (
                <div className="bg-green-50 border border-green-200 rounded-lg p-4 sm:p-5">
                  <h4 className="font-semibold text-sm sm:text-md text-green-700 flex items-center space-x-2">
                    <HelpCircle className="w-4 h-4 text-green-500 flex-shrink-0" />
                    <span>Troubleshooting Tips</span>
                  </h4>
                  <ul className="mt-3 space-y-2 sm:space-y-3">
                    {stages[currentStage].troubleshooting.map((tip, index) => (
                      <li
                        key={index}
                        className="text-green-700 text-xs sm:text-sm flex items-center space-x-2"
                      >
                        <div className="w-1.5 h-1.5 rounded-full bg-green-500 flex-shrink-0"></div>
                        <span>{tip}</span>
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      <style jsx>{`
        @keyframes float {
          0% {
            transform: translateY(0) scale(1);
            opacity: 1;
          }
          100% {
            transform: translateY(-100px) scale(0);
            opacity: 0;
          }
        }
      `}</style>
    </div>
  );
};

export default LinuxBootingVisualizer;
